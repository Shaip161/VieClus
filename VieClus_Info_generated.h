// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VIECLUSINFO_VIECLUSINFO_H_
#define FLATBUFFERS_GENERATED_VIECLUSINFO_VIECLUSINFO_H_

#include "flatbuffers/flatbuffers.h"

namespace VieClusInfo {

struct Partition;
struct PartitionBuilder;

struct GraphMetadata;
struct GraphMetadataBuilder;

struct RunTime;
struct RunTimeBuilder;

struct ClusteringMetrics;
struct ClusteringMetricsBuilder;

struct MemoryConsumption;
struct MemoryConsumptionBuilder;

struct Partition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartitionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPH_METADATA = 4,
    VT_RUNTIME = 6,
    VT_MEMORY_CONSUMPTION = 8,
    VT_CLUSTERING_METRICS = 10
  };
  const VieClusInfo::GraphMetadata *graph_metadata() const {
    return GetPointer<const VieClusInfo::GraphMetadata *>(VT_GRAPH_METADATA);
  }
  const VieClusInfo::RunTime *runtime() const {
    return GetPointer<const VieClusInfo::RunTime *>(VT_RUNTIME);
  }
  const VieClusInfo::MemoryConsumption *memory_consumption() const {
    return GetPointer<const VieClusInfo::MemoryConsumption *>(VT_MEMORY_CONSUMPTION);
  }
  const VieClusInfo::ClusteringMetrics *clustering_metrics() const {
    return GetPointer<const VieClusInfo::ClusteringMetrics *>(VT_CLUSTERING_METRICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRAPH_METADATA) &&
           verifier.VerifyTable(graph_metadata()) &&
           VerifyOffset(verifier, VT_RUNTIME) &&
           verifier.VerifyTable(runtime()) &&
           VerifyOffset(verifier, VT_MEMORY_CONSUMPTION) &&
           verifier.VerifyTable(memory_consumption()) &&
           VerifyOffset(verifier, VT_CLUSTERING_METRICS) &&
           verifier.VerifyTable(clustering_metrics()) &&
           verifier.EndTable();
  }
};

struct PartitionBuilder {
  typedef Partition Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_graph_metadata(flatbuffers::Offset<VieClusInfo::GraphMetadata> graph_metadata) {
    fbb_.AddOffset(Partition::VT_GRAPH_METADATA, graph_metadata);
  }
  void add_runtime(flatbuffers::Offset<VieClusInfo::RunTime> runtime) {
    fbb_.AddOffset(Partition::VT_RUNTIME, runtime);
  }
  void add_memory_consumption(flatbuffers::Offset<VieClusInfo::MemoryConsumption> memory_consumption) {
    fbb_.AddOffset(Partition::VT_MEMORY_CONSUMPTION, memory_consumption);
  }
  void add_clustering_metrics(flatbuffers::Offset<VieClusInfo::ClusteringMetrics> clustering_metrics) {
    fbb_.AddOffset(Partition::VT_CLUSTERING_METRICS, clustering_metrics);
  }
  explicit PartitionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Partition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Partition>(end);
    return o;
  }
};

inline flatbuffers::Offset<Partition> CreatePartition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<VieClusInfo::GraphMetadata> graph_metadata = 0,
    flatbuffers::Offset<VieClusInfo::RunTime> runtime = 0,
    flatbuffers::Offset<VieClusInfo::MemoryConsumption> memory_consumption = 0,
    flatbuffers::Offset<VieClusInfo::ClusteringMetrics> clustering_metrics = 0) {
  PartitionBuilder builder_(_fbb);
  builder_.add_clustering_metrics(clustering_metrics);
  builder_.add_memory_consumption(memory_consumption);
  builder_.add_runtime(runtime);
  builder_.add_graph_metadata(graph_metadata);
  return builder_.Finish();
}

struct GraphMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_NUM_NODES = 6,
    VT_NUM_EDGES = 8
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  uint64_t num_nodes() const {
    return GetField<uint64_t>(VT_NUM_NODES, 0);
  }
  uint64_t num_edges() const {
    return GetField<uint64_t>(VT_NUM_EDGES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyField<uint64_t>(verifier, VT_NUM_NODES, sizeof(uint64_t)) &&
           VerifyField<uint64_t>(verifier, VT_NUM_EDGES, sizeof(uint64_t)) &&
           verifier.EndTable();
  }
};

struct GraphMetadataBuilder {
  typedef GraphMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(GraphMetadata::VT_FILENAME, filename);
  }
  void add_num_nodes(uint64_t num_nodes) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_NUM_NODES, num_nodes, 0);
  }
  void add_num_edges(uint64_t num_edges) {
    fbb_.AddElement<uint64_t>(GraphMetadata::VT_NUM_EDGES, num_edges, 0);
  }
  explicit GraphMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GraphMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GraphMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<GraphMetadata> CreateGraphMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0,
    uint64_t num_nodes = 0,
    uint64_t num_edges = 0) {
  GraphMetadataBuilder builder_(_fbb);
  builder_.add_num_edges(num_edges);
  builder_.add_num_nodes(num_nodes);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<GraphMetadata> CreateGraphMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    uint64_t num_nodes = 0,
    uint64_t num_edges = 0) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return VieClusInfo::CreateGraphMetadata(
      _fbb,
      filename__,
      num_nodes,
      num_edges);
}

struct RunTime FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RunTimeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IO_TIME = 4,
    VT_MAPPING_TIME = 6,
    VT_TOTAL_TIME = 8
  };
  double io_time() const {
    return GetField<double>(VT_IO_TIME, 0.0);
  }
  double mapping_time() const {
    return GetField<double>(VT_MAPPING_TIME, 0.0);
  }
  double total_time() const {
    return GetField<double>(VT_TOTAL_TIME, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_IO_TIME, sizeof(double)) &&
           VerifyField<double>(verifier, VT_MAPPING_TIME, sizeof(double)) &&
           VerifyField<double>(verifier, VT_TOTAL_TIME, sizeof(double)) &&
           verifier.EndTable();
  }
};

struct RunTimeBuilder {
  typedef RunTime Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_io_time(double io_time) {
    fbb_.AddElement<double>(RunTime::VT_IO_TIME, io_time, 0.0);
  }
  void add_mapping_time(double mapping_time) {
    fbb_.AddElement<double>(RunTime::VT_MAPPING_TIME, mapping_time, 0.0);
  }
  void add_total_time(double total_time) {
    fbb_.AddElement<double>(RunTime::VT_TOTAL_TIME, total_time, 0.0);
  }
  explicit RunTimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RunTime> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RunTime>(end);
    return o;
  }
};

inline flatbuffers::Offset<RunTime> CreateRunTime(
    flatbuffers::FlatBufferBuilder &_fbb,
    double io_time = 0.0,
    double mapping_time = 0.0,
    double total_time = 0.0) {
  RunTimeBuilder builder_(_fbb);
  builder_.add_total_time(total_time);
  builder_.add_mapping_time(mapping_time);
  builder_.add_io_time(io_time);
  return builder_.Finish();
}

struct ClusteringMetrics FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClusteringMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCORE = 4,
    VT_CLUSTERING_AMOUNT = 6
  };
  double score() const {
    return GetField<double>(VT_SCORE, 0.0);
  }
  uint64_t clustering_amount() const {
    return GetField<uint64_t>(VT_CLUSTERING_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCORE, sizeof(double)) &&
           VerifyField<uint64_t>(verifier, VT_CLUSTERING_AMOUNT, sizeof(uint64_t)) &&
           verifier.EndTable();
  }
};

struct ClusteringMetricsBuilder {
  typedef ClusteringMetrics Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_score(double score) {
    fbb_.AddElement<double>(ClusteringMetrics::VT_SCORE, score, 0.0);
  }
  void add_clustering_amount(uint64_t clustering_amount) {
    fbb_.AddElement<uint64_t>(ClusteringMetrics::VT_CLUSTERING_AMOUNT, clustering_amount, 0);
  }
  explicit ClusteringMetricsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClusteringMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClusteringMetrics>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClusteringMetrics> CreateClusteringMetrics(
    flatbuffers::FlatBufferBuilder &_fbb,
    double score = 0.0,
    uint64_t clustering_amount = 0) {
  ClusteringMetricsBuilder builder_(_fbb);
  builder_.add_clustering_amount(clustering_amount);
  builder_.add_score(score);
  return builder_.Finish();
}

struct MemoryConsumption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MemoryConsumptionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OVERALL_MAX_RSS = 4
  };
  int64_t overall_max_rss() const {
    return GetField<int64_t>(VT_OVERALL_MAX_RSS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OVERALL_MAX_RSS, sizeof(int64_t)) &&
           verifier.EndTable();
  }
};

struct MemoryConsumptionBuilder {
  typedef MemoryConsumption Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_overall_max_rss(int64_t overall_max_rss) {
    fbb_.AddElement<int64_t>(MemoryConsumption::VT_OVERALL_MAX_RSS, overall_max_rss, 0);
  }
  explicit MemoryConsumptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MemoryConsumption> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemoryConsumption>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemoryConsumption> CreateMemoryConsumption(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t overall_max_rss = 0) {
  MemoryConsumptionBuilder builder_(_fbb);
  builder_.add_overall_max_rss(overall_max_rss);
  return builder_.Finish();
}

inline const VieClusInfo::Partition *GetPartition(const void *buf) {
  return flatbuffers::GetRoot<VieClusInfo::Partition>(buf);
}

inline const VieClusInfo::Partition *GetSizePrefixedPartition(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<VieClusInfo::Partition>(buf);
}

inline bool VerifyPartitionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<VieClusInfo::Partition>(nullptr);
}

inline bool VerifySizePrefixedPartitionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<VieClusInfo::Partition>(nullptr);
}

inline void FinishPartitionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VieClusInfo::Partition> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPartitionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VieClusInfo::Partition> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace VieClusInfo

#endif  // FLATBUFFERS_GENERATED_VIECLUSINFO_VIECLUSINFO_H_
